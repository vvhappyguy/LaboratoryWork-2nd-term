/* Лабораторная работа №1
 * Тема: Связный список с итератором
 * Цель: Закрепления навыков по областям: 
 * - структуры данных
 * - алгоритмы
 * - работа с динамической памятью
 * - простые классы и объекты
 * - дружественные классы и функции
 * - ссылки и указатели
 * - конструкторы и деструкторы
 * - константные и неконстантные методы
 * - раздельная компиляция и сборка проекта, make, (опционально: сборка библиотек)
 * Задание: 
 * - Разработать и отдладить класс 
 * "Двунаправленный Связный Список с доступом через итератор"
 * - продемонстрировать работу по 
 *   - наполнению списка, 
 *   - итерацию элементов списка
 *   - добавление и удаление элементов в списке в позиции, указываемой итератором
 *   - предусмотреть метод или дружественную функцию, переворачивающую список 
 *   (т.е. меняющую последовательность элементов списка на обратную)
 *   - предусмотреть метод или дружественную функцию для объединения двух списков в один. (с передачей владения в один список)
 *   - Дополнительное задание: реализовать алгоритм быстрой сортировки Хоара на этом классе
 * */

// Примерный прототип класса 

class ListInt
{
	private:
		class Node // класс узла списка - полностью инкапсулирован и недоступен снаружи класса ListInt
		{
			int _value;
			Node *_prev *_next;
			Node();
			public:
			Node(int value);
			int& value();
			int  value() const;
			Node*& prev();
			Node*& next();
		};
		Node *_head, *_tail;  // Указатели на голову и хвост списка
		size_t _size;         // количество элементов
	public:

		ListInt();  // default c-tor
		~ListInt(); // d-tor

		size_t size() const; // получить количество
		bool empty() const;  // предикат пустого списка

		void reverse();      // поменять порядок на обратный
		void grab_and_append(ListInt& from); // забрать все элементы у другого списка и добавить их в конец этого
		void sort();         // отсортировать по возрастанию (потом, когда пройдем перегрузку операторов, можно 
		                     // добавить сюда параметр - функтор сравнения на меньше для любого порядка сортировки)

		class iterator // класс итератора списка
		{
			private:
				Node *_current;
			  iterator(Node* node); // основной конструктор: запрещен для использования вне списка
			  friend class ListInt; // чтобы воспользоваться этим конструктором из ListInt он должен быть объявлен дружественным 
			public:	
				iterator(const iterator&) // copy c-tor
				~iterator();

				bool valid() const; // true если _current != NULL
				
				// получить данные
				int& get(); 
				int get() const; 

				void prev(); // перейти к _current->next()
				void next(); // перейти к _current->prev()

				bool equal(const iterator& other) const;
		};

		// фабрики итераторов
		iterator head();
		iterator tail();

		iterator insert(iterator pos, int value);  // возвращает позицию после вставленной
		iterator erase(iterator& pos); // Обратить внимание: после удаления узла итератор позиции должен стать инвалидным
		                               // возвращает итератор указывающий на узел следующий после удаленного

		void push_back(int val); // добавление в конец
		void pop_back(); // выкинуть последний элемент
		//...
};

// Примерный сценарий применения:

{

	ListInt l;
	l.push_back(1);
	l.push_back(2);
	l.push_back(3);
	l.push_back(4);
	l.push_back(5);

	for(ListInt::iterator it = l.head(); l.valid(); l.next())
		cout << l.get() << endl;

	l.reverse();

	for(ListInt::iterator it = l.head(); l.valid(); l.next())
		cout << l.get() << endl;

	l.sort();

	for(ListInt::iterator it = l.head(); l.valid(); l.next())
		cout << l.get() << endl;

	cout << "size: " << l.size() << endl;

	// ....
}



